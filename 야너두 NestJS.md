## BullMQ 메세지 큐

### 메시지큐 이해하기

- 서버간 메시지를 담아두는 가상의 회선
- 만약 수신자 서비스가 죽는다면 요청을 받지 못해 장애 전파 발생 → 메세지큐 도입(비동기 작업)
- 메시지를 담는 하나의 데이터베이스
- FIFO Queue, Not Ordered Queue(순서 X)

### BullMQ 이해하기

- Redis를 이용하는 메시지 큐
- 레디스, 루아 스크립트를 통해 통신, ioredis를 사용하여 접근
- Redis를 메시지 저장소로 사용하고, 정확히 한 번 이상의 제공을 보장한다.

### 구성요소

- 큐
    - 실제로 메세지를 저장하는 저장소
    - 다양한 옵션을 통해 큐를 제어할 수 있다.
    - 전송시 5개의 키가 생성
        - Stream type: 해당 큐에 발생한 이벤트
        - String type: 마지막으로 등록된 잡의 id
        - Hash type: 큐에 대한 메타데이터
        - Hash type: 잡 정보
        - List type: 실행중인 잡 아이디
- Worker
    - 전달받은 메시지를 소비하는 컨슈머
    - 다양한 옵션으로 제어 가능
    - 주기적으로 레디스와 통신하며 수행중인 작업을 보고한다.
    - job 상태 정의 그림
    - concurrency
        - 동시성을 가지고 수행할 잡의 개수
        - while로 작업을 가져온다.
        - asyncFifoQueue가 현재 작업중인 잡이 들어가는 곳
        - concurrency 개수만큼 async 함수가 들어간다.(Promise.all())
    - 워커의 구현체 (두번째 인자)
- 작업(Job)
    - 큐로 발행하는 메세지
    - 프로듀서는 큐로 잡을 발행하고, 워커는 큐로부터 잡을 구독받는다.
    - 잡을 실행할 때 다양한 설정 가능
- 절차(Flow)
- 이벤트
    - 큐와 워커에서 발행하는 이벤트
    - 큐에서 잡이 대기를 시작하거나 워커에서 잡이 끝났을때나 실패했을 때, 큐에서 작업이 드레인될때 등

### BullMQ NestJS에서 사용하기

- BullModule, Decorator
- forRoot() - 기본 설정
- registerQueue() - 해당 큐를 생성하기 위한
- registerFlowProducer()
- @InjectQueue - 인젝트 역할
- @Procesor - 워커 클래스 컴포넌트 선언
- @OnWorkerEvent
- @QueueEventListener
- 기본적으로 모듈 데코레이터에 구현체를 넣으면 코드 관리에 어려움이 있음

### 용례

- 간단한 경량 메시지 큐가 필요할 때
- 비동기 작업을 수행시키고 싶을 때
- 테스크를 돌리고싶을 때
- 스크립트를 통한 마이그레이션

### 사용 후기

- 엄청 좋음
- 수평적 확장에도 매우 유리하다
- 워커 확장 및 감소가 자유롭다
- 레디스를 써서 어느정도의 원자성이 보장되기 때문
- 워커에서 노드 이벤트 루프를 막으면 멱등성 이슈 발생
- 레디스에 대해 잘 이해해야 안정적으로 운영 가능

### 사용 시 주의사항

- 두개의 워커가 똑같은 작업을 하는 이유
- stalled(작업 실행 보고) → timeout 30초
- 30초동안 이벤트 루프 막히면 실패했다고 간주 → 워커2가 같이 실행
- 30초이상 막으면 안된다.

---

## busboy를 활용해 서버 부하없이 파일 업로드하기

### 보통의 파일 업로드 - 서버 부하 O

- base64 string으로 body에 담아서 전송가능
    - 간단하지만 데이터가 무지막지하게 길어진다
    - 파일용량 33% 증가
- s3 presignedUrl
    - 서버가 관리할 수 없는 곳에 엮임(아마존)
    - 오류발생 시 xml형식으로 에러 응답함
- multipart/form-data (multer)
    - json에 비해서 관계 파악이 어렵다
    - 디스크 스토리지/메모리 스토리지 방식/커스텀s3

### 우리의 상황

- MSA 환경
- API 서비스 환경에서 파일을 업로드하고싶다
- base64: 매우 긴 바디 + json parser 용량 제한, 보안 위험, 인코딩/디코딩 엄청 느림

### 새로운 방법

1. API 게이트웨이 + 람다
2. **multer + Stream**

### Busboy

- Writable Stream

### Busboy + NestJS 더 잘 쓰기

- Nodejs에는 스트림 버전이 있는데, 최근 노드는 스트림 2사용
- 스트림2에는 기본적으로 제공되는 backpressure 기능이 있는데 매우 많은 데이터가 들어오면 오류 발생

---

microORM, typeORM, Prisma

이벤트모듈, 불모듈 뜯어보기

메모리, 디스크io를 사용하면서 발생할 수 있는 부하를 차단하고 Stream을 사용하여 S3에 한꺼번에 올리기

bullMQ: 하나의 작은 서비스 내에서 메세지 큐를 사용하고자 할 때 편함

api 버저닝
