https://jaehoney.tistory.com/224

## 레거시에서 살아남기

> [https://velog.io/@kshired/DevOps-Feature-flag란-무엇일까](https://velog.io/@kshired/DevOps-Feature-flag%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
> 
- Feature flag (Feature toggles)
    - 코드를 수정하지 않고 시스템 동작을 변경하는 기술
    - 시스템 동작에 영향을 미치는 거대한 조건문 집합
    - 운영적인 기능으로 on/off 기능을 두는 것
- 특정 사람에게만 권한을 열어 결제 시스템을 이용 (Permission)
- 카나리 릴리즈(바로 배포하긴 무서우니 점진적 배포)
    - userId 연산을 통해 feature 노출
- A/B 테스팅
- 릴리즈 플래그
    - 불완전한 기능을 테스트 하기 위해 코드를 숨긴채로 기능
    - `TBD 전략`, 하나의 메인 브랜치에 계속 배포 → 장애 우려 → 피쳐 플래그 사용(on/off)
    - 머지를 해결하는 리소스를 줄이기 위해 피쳐 플래그를 사용하고 메인에 머지
- 실험 플래그
    - A/B 테스트, 개인화 등을 위해 사용되는 플래그
- 운영 플래그
    - 외부 시스템 이중화(지도 API 등 외부 API가 오류나면 꺼야함)
- 권한 플래그
    - 특정 사람들에게만 열어주는 플래그 (카카오 실험실)
    - 카나리는 무작위로 선정되는 사용자, 권한 플래그는 특정 고객에게만 노출된다.
- firebase Remote config → real time 지원
    - 실시간 업데이트 리슨 → 실시간으로 콘솔에서 config 값을 바꿨을 때
- 하드 코딩, 매개변수 설정 → if/else, properties 설정
- DB, 캐시, config 관리 도구 변경
- OpenFeature/js-sdk open source

### 실제 구현

- GrowthBook 오픈소스
- 토글 포인트, 토글 라우터, 토글 설정
    - 포인트
    - 라우터: 해당 플래그가 켜진지 아닌지 판단 (단순 on/off 기능만 쓰지않고 추가적인 비즈니스 로직 필요)
    - 토글: on/off 룰 관련 기능

### 구현 원칙

1. on일 땐 신규 feature, off일 땐 기존 feature
2. 토글 포인트/토글 라우터 분리
    1. 관심사의 분리
    2. 어떤 과정을 거쳐서 toggle이 on/off인지 분리
    3. if-else를 통해 어떤 메소드를 실행할지는 토글 포인트의 역할
3. feature flags 구현체는 언제든 변경 가능
4. 토글 설정 값은 동적으로 변경 가능
5. Fault Tolerance

### Spring boot + open feature + 그로스북과 조합

- AOP, featureFlag 어노테이션이 있는 경우에 사용
- 서비스단에 해당 어노테이션을 달고, 이에 대한 콜백 메소드 정의
- 해당 피쳐가 켜있음 메소드를 타고, 아니면 old feature 메소드를 탄다.
- `if (isOn) { … } else { … }`
- cloudEvent(메세지 큐)

### 단점

- 관리해야할 플래그가 늘어난다
- 트레이드 오프 존재
- 어떤 기능이 살아있는지 아닌지 잘 모름(추적 어려움)
- 관리되지 않는 코드가 늘어나게된다.
    - 릴리즈 플래그 관리 잘해야함..
- MSA → 모놀리스로 다시 돌아가는 추세
    - 새 기술 도입할 땐 신중하게 도입해야함

요즘은 표준이 없기 떄문에 알아서 판단..

늘어나는 멜론의 기술 부채

---

## Redis와 Sentinel의 ping-pong 이야기 (sentinel의 redis health check)

> https://redis.io/docs/management/sentinel/
> 
- 레디스 센티넬 구조로 설계된 시스템에서 장애 발생
- 센티넬로 레디스롤 모니터링하고 auto failover하면서 장애 발생
- 센티넬에서 장애로 인식하는 과정에 대한 호기심
- RDB? NoSQL?
    - Redis는 NoSQL의 구조를 가진다(key-value, document, ….)
    - 데이터간의 관계를 정의하지 않음
    - ELK도 NoSQL
- In Memory  DB- NoSQL의 형태
    - 캐시에 데이터를 적재하여 사용
    - 대표적으로 redis
    - 휘발성이라 전원 꺼지면 답없음
- Redis vs Memcached
    - Redis 시간 복잡도 O(N), 많은 자료구조 제공, 클러스터 모드 제공, 미리 지정된 크기만큼 단위로 할당되기 때문에 메모리 파편화를 일으킴
    - 멤캐시 멀티 스레드 사용, 자료구조 제한적, 클러스터 모드나 레플리케이션 제공하지 않음
    - 메모리 부족한경우 가장 적게 사용된 데이터부터 삭제 (데이터가 삭제될 우려 O)
    - 자료형 - String (key, value), list는 중간에 넣을 경우 시간이 느리다, Set은 중복되지않은 값, Sorted Set의 경우 랭킹을 저장할 때 많이 사용(일반 set과 달리 정렬, 순서 O)
- Redis 사용 예
    - 여러 서버에 데이터 공유
    - 인증 토큰 저장
    - 랭킹 보드(Sorted Set)
    - 유저 API limit
- Redis Replication vs Redis 데이터 분산
    - Redis Replication
        - A서버의 데이터를 B서버에도 동일하게 가지는 것
        - 복사본을 하나 가지는 것과 같ㅇ다.
        - master-slave, Original-Replica, Primary-Secondary (5.0, replicaOf, slaveOf)
        - replication 과정에서 fork 가 발생하기 때문에 메모리가 부족할 수 있음
        - Async replication으로 약간의 시차가 발생할 수 있음 (복제 시간)
        - 데이터 차이가 큰 경우 연결을 끊고 재연결하기 떄문에 부하 발생 가능성
        - Replication 구조에서는 failover를 할 수 없기 때문에 수동으로 진행
        - Sentinel을 사용하여 헬스쳌
    - Redis Master - Redis slave 1, 2
- Redis Persistence (데이터의 영속성, 백업)
    - 램 영역은 휘발성이기 때문에 데이터 유실 가능성이 높다
    - 따라서 Redis Persistence 방식이 있는데 RDB 방식과 AOF 방식이 있다.
    - RDB
        - Config 파일에 설정된 값에 따라 데이터의 스냅샷을 찍어 파일로 저장한다.
        - 특정 시ㅏㄴ 간격 또는 데이터 입력값에 따라 스냅샷을 저장할 수 있다.
        - 데이터 복구시 해당 파일을 이용해 복구 가능
    - AOF(Append Only File)
        - Write 작업이 일어날 때마다 File에 로그처럼 해당 명령이 기록되며 7.0부터 여러개의 파일로 저장된다.
        - Redis가 다시 살아날 때 write 작업들을 다시 실행하여 서버가
- Redis Persistence 고려 사항
    - 무조건 마스터 슬레이브 구조
    - 메모리를 절대 빡빡하게 사용하면 안된다
        - 가능하면 자동화 툴을 만들어서 이용
        - 정기적인 마이그레이션 필요
    - RDB, AOF가 필요하면 Secondary에서만 구동해야한다. (master에서는 백업하면 안됨)
- 레디스 데이터 분산
    - consistenct hashing
        - Application에서 처리하는 방식
    - 샤딩
        - Application에서 처리하는 방식
        - 같은 테이블을 데이터 기준으로 나누는 방식
        - 스키마가 동일해야한다.
        - 다양한 방식 존재
    - redis cluster
        - 해쉬 기반으로 슬롯 구분
        - 클러스터 내에서 헬스체크
        - 메모리 사용량이 많고 별도 라이브러리 필요
- 클러스터 구조
    - 클라이언트가 각각의 레디스 마스터에 접근

### sentinel

- 레디스에 함꼐 포함, config가 다르게 만들어야함
- 센티넬을 통한 고가용성
    - 비 클러스터링형 레디스의 고가용성
    - 레디스 센티넬은 레디스 클러스터를 사용하지 않을 때 레다스에 고가용성을 제공한다.
    - 모니터링, 알림과 같은 기타 부차적 작업을 제공하고 클라이언트에 대한 구성 공급자 역할을 한다.
    - 모니터링, 알림, 자동 장애 조치, 구성 공급자
- 센티넬에 대해 알아야할 기본 사항
    - 센티넬은 최소 3개의 인스턴스가 필요하다
    - 센티넬 도커 구성의 경우 조심해야할점 → 도커 자체에서 포트 떄문에 정보 안맞아서 failover 문제 발생 위험 O
- 고려사항
    - 센티넬은 홀수로 증가 → 센티넬끼리 레디스 죽었는지 체크 → 체크 과정에서 투표
    - 쿼럼이 2 이상(과반수 이상)이 되어야지 fail over하는 것을 동의한다.
    - 센티넬 구조는 소규모 프로젝트에 적합한 구조, 대규모는 샤딩이나 클러스터링을 사용하는 것이 좋다
        - 센티넬은 구성은 쉽고 간단히 모니터링 할 수 있음 but 대규모는 메모리 사용량이 많고 데이터를 관리하는 것이 어렵다
    - 센티넬은 master 역할을 하는 애가 정해지는데, 이들끼리 투표해서 리더 선출

### 센티넬 모니터링

- 수동으로 관리자가 명령을 진행
- redis cli를 통해
- used memory - 레디스가 알고있는 사용 메모리
- cpu 성능체크: 레디스는 싱글스레드라 cpu를 하나만쓰기 때문에 성능 좋은걸 쓰는 것이 좋다
- 센티넬을 통한 레디스 헬스체크

### 센티넬 구조도

- 센티넬1 레디스1 (master, slave 구분없이 붙어서 체크)
- 만약 마스터가 죽으면 센티넬이 죽었다고 인식 → 새 리더 창출
    - 다운된 마스터는 슬레이브로 전환
- 센티넬과 레디스는 ping-pong
- 시작점은 센티넬커맨드 함수

### pong을 받은 Sentinel

- 만약 센티넬에서 응답 못받은경우 pub/sub 구조로 서로 정보 공유
- 센티넬 리더가 체크

---

## Netty와 Armeria 비동기 서버 이벤트 루프 코드 뜯어보기

https://github.com/netty/netty

- Nodejs 이벤트루프 직접 뜯어보기
- 이벤트루프란?
    - 특정 이벤트가 ㅂ발생할 때까지 대기하다가 발생하면 적절한 이벤트를 호출하여 처리하는 프로그래밍
- 이벤트 루프 구현체
    - 네티
    - 레디스 (싱글스레드)
    - libuv (node)
- 네티 이벤트 루프
    - 자바 IO는 블로킹 IO를 사용 → 커넥션마다 하나씩 스레드를 할당하기 떄문에 유저가 많이들어오면 느려짐
    - 자바에서 NIO를 지원하면서 준비된 커넥션들만 바로 알려줄 수 있게 됨
    - 네티는 자바 NIO, 소켓은 채널로 추상화, 셀렉터에 읽을 준비가된 채널들을 불러와서 네티 이벤트 루프가 싱글 스레드로 동작
    - 채널 파이프라인으로 추상화, 채널 핸들러 추상화 → 등록된 핸들러에게 디스패치
    - 네티는 커넥션마다 스레드를 만들필요없음, 싱글 스레드로 이벤트 루프가 동작하면서 디스패치
- 이벤트 루프는 하나일 필요는 없음, 그룹이 존재
- 네티는 싱글 스레드 이벤트 루프 동작 → 자바 블로킹에 비해 논블로킹 + 이벤트 드리븐으로 동작하기 떄문에 동기화가 필요없음
    - 레디스도 싱글스레드로 동작하는 이유는 빠르게 처리하기 위함
    - 확장성

### 코드 뜯어보기

- NIOEventLoop
    - 싱글 스레드 이벤트 루프 구현체
    - 채널들에 대한 멀티플렉싱 수행
    - 실제로 싱글 스레드로 동작, 채널 처리, 스케줄 테스트 처리
- processSelectedKeys: ready인 상태의 채널들을 받아서 이벤트 쏴줌
    - SelectionKey, NioChannel
    - unsafe class → OS에 밀접, 웬만하면 호출하지 말것
    - unsafe.read()
- runAllTasks()
    - 큐잉, 스케줄된 테스크 처리
    - 테스크 큐와 스케줄드 테스크 큐를 가진다.
        - 하트비트, 주기적인 동작 등을 스케줄링 걸어두거나 할 때 사용
- scheduledTaskQueue - 우선순위 큐 동작

### 요약

- 실제 싱글 스레드 이벤트 루프를 상속받음
- 논블로킹 io, 이벤트 루프로 동작, 싱글 스레드 → 내부 자료구조에 대한 동기화가 필요없음
- 10K problem → 소프트웨어, 자바 Nio를 이용해 해결한 좋은 사례
- 논블로킹은 싱글스레드의 장점을 잘 조합하여 구현해놓은 것 같음

### 이벤트 루프를 블로킹하지 마세요

- 이벤트 루프 안에서 블로킹 API를 호출하면 안되는 이유
    - 이벤트 루프는 싱글 스레드로 돌아가기 때문에 실행되는 채널 파이프라인에서 mysql db에서 블로킹 걸고 response를 기다리는 식으로 실행하면 이벤트 자체가 블로킹되어버림
    - 다른 이벤트를 처리할 수 없는 문제 발생
- 당연하게도 블로킹 API는 별도의 스레드에서 호출해줘야함 → 그 결과를 다음 채널 핸들러에 넘겨줘야 네티에서 최고 성능을 뽑을 수 있음
- mysql에서 블로킹콜을 다른 스레드에서 실행했지만, 응답 결과를 넘겨줄 때는 다시 이벤트 루프로 돌아가서 실행
    - 이벤트 루프를 싱글 스레도 설계한 이유
    - 채널 액티브, 바이트 읽고 쓰기, 인액티브 등과 같은 채널 안에서 실행하는 다양한 코드 존재
    - 싱크로나이즈 없이 이러한 것들을 처리 + 순차적으로 처리하고 싶기때문
    - 네티에서 이러한 것들을 가정하고 코드를 짜는데, 이런 과정을 어기고 이벤트 루프안에 있는 것들을 실행하면 동기화가 필요없다는 규칙이 깨짐
    - **결론적으로 블로킹 API를 부를 때 다른 스레드에서 처리하더라도 이벤트 결과는 이벤트 루프로 다시 돌아가야한다.**

### Netty + Armeria

- 라인에서 개발하는 비공개 오픈소스 아르메리아
- 마이크로 서비스를 만드는데 유용한 기능들을 다 넣어놓음
- 명시적으로 코드를 넣어서 우리 페이스에 맞게 개발 가능
- 네티 위에서 동작하기 떄문에 논블로킹 io를 최대한 지원, 스트링 처리로 데이터를 잘라서 보냄
- 네트워크 계층에 네티, 그 위에 아르메리아
- http2, grpc 등의 다양한 프로토콜 핸들러 지원
- msa를 만들 때 유용한 기능들을 제공
- RxJava 를 사용하여 비동기 처리 가능

### armeria streaming

- 스트림 메시지 수신 시 request 한 만큼 잘라서 보내줄 수 있음
- 메모리에 다 띄우지 않고 요청한 만큼만 받을 수 있음

---

## 모듈러 모놀리스 살펴보기

- 우아한 모노리스 책 (2020)
- 아마존 프라임 비디오 서비스를 모듈러 모놀리스로 전환(2023)
- 스프링부트3 스프링 모듈리스(2023)
- 치얼스 앱
- 모듈러(Moduler) + 모놀리스(Monolith)
    - 모놀리스는 하나의 통일감있는 형태, 물체를 의미함
    - 모듈러 모놀리스는 분해할 수 있는 것과 일체감있는 것들의 조합(모순적)
- 마틴 파울러: 님 앱이 나중에 커져도 시작을 msa로 시작하지마라
    - 어느정도 일정수준에 도달하면 모놀리스는 생산성이 확 떨어지게됨(규모가 커지기 시작)
    - 시작은 모놀리스, 필요하면 msa

### 모놀리스 vs msa

- 모놀리스의 경우 큰 원안에 모든 코드들이 다 들어있음 (하나의 어플리케이션 안에 다양한 기능들이 모임)
- msa의 경우 여러 기능들을 각각 나눠서 처리, DB도 여러개
- 모놀리스는 모든 기능이 하나의 앱, 마이크로서비스는 기능들을 여러개의 어플리케이션으로
- 모놀리스는 ㄱ고전적인 개발 방법, 마이크로서비스는 큰 규모의 기업들이 선택하는 구조
- 모놀리스는 하나의 서버 배포, msa는 여러 서버 배포
- 모놀리스 메소드 콜 통신, msa는 network call 통신
- 모놀리스는 데이터 정합성을 위한 트랜잭션, msa는 최종적 일관성
- 모놀리스는 일부 구성 교체 불가, msa는 다른 프레임워크로 교체 가능하다

### 모듈러 모놀리스의 필요성

- layered 아키텍처(controller-service-repository)
    - 의존성이 서로 꼬이는 형태가 발생..
    - 개발할 땐 문제가 없는데 명언 기능이 너무 커져서 분리하고 싶을 때 문제가 된다.
- 명언 모듈/ 유저모듈/ 푸시모듈 이런식으로 분리해서 사용
    - 의존성이 서로 얽히지 않음
- 모듈화 안된 모놀리스와 msa와의 비교
    - 모놀리스는 비즈니스별 물리적, 개념적 분리 x, 마이크로서비스는 물리적 개념적으로 잘 분리됨
    - 모듈러 모놀리스는 물리적으로는 하나지만 개념적으로는 분리됨

### 모듈러 모놀리스 살펴보기

- 바깥은 하나의 서버, 안에는 여러가지 컴포넌트 존재
    - 도메인 관리 컴포넌트
    - 각 모듈을 jar 파일로 빌드 → 마지막으로 하나씩 모아서 하나로 배포하는 것이 모듈러 모놀리스
- 만약 명언 서비스가 너무 커지게 되면 잘 모듈화 되어있기 때문에 따로 msa로 가능(메소드 콜 → 네트워크 콜)
- 하나의 기능이 망할 경우 대체도 쉬움
- 각 모듈별로 팀도 배정 가능
- 어플리케이션 모듈, 도메인 로직 처리 모듈로 분리
    - 어플리케이션은 의존성만, 도메인 로직은 의존성 없이 도메인 로직만 처리한다.
    - 클린아키텍처, 헥사고날이 지향하는 바와 비슷하다.
    - 의존성이 없도록!
    - 기능별로 나누는 것에서 넘어서 코드 퀄리티를 높일 수 있음
- 모듈러로 찢어놓은 경우 아예 주입이 안됨
    - 의존한다 = 도메인 로직까지는 영향이 안감(레이어 1단계까지는 의존 가능)
    - 어플리케이션 모듈 단에서는 번역 도메인 로직, 이미지 도메인 로직은 알수 없음(은닉화) → 명언 어플리케이션 모듈에서 실수로 도메인 로직을 의존할 수 없다는 장점이 있음
- 단점
    - 트래픽이 늘어나는 경우 모듈러 모놀리스의 구조라 하나의 서버에 있어서 확장 불가 → msa 필요
    - 회원 도메인에 장애가 난 경우 다른 도메인도 작동안됨→ 장애 전파가 쉽다.

### 모듈러 모놀리스를 도입할 때…

- bounded context는 모듈을 나눌 때도 유용하다
    - 기능에 대해서 나눌 때 모듈이나 어떤 서비스를 나눌 때 기능이 아니라 비즈니스별로 나누는 것
- 의존이 너무 많은 경우에는 그냥 하나로 합치는 것이 낫다.

### DB도 비즈니스 관심사를 분리해야한다.

- 명언 도메인, 이미지 도메인이 같은 테이블을 조회한다고 가정하자. (이러면 안됨)
- msa처럼 각 서비스 별로 다른 Db를 가지니 최소한 논리적으로라도 분리해야함(테이블 단에서라도 해야함)
- 같이 접근하는 경우 → JOIN하는 경우
- best practice는 모든 msa처럼 서비스별로 db를 나누는 것이 좋지만…불가능
- **순환참조는 반드시 피해야한다**
    - 순환 참조를 피하는 방법은 하이라키를 정하는 것 (위계질서)
    - 역행은 하지 않고 위에서 아래로만 참조 가능 → 순환 참조를 막을 수 있음
- json protocol을 쓸 필요가 없는게 이미 하나의 어플리케이션이기 때문에 네트워크 콜이 아니라 메소드 콜이기 때문
- Implement로 의존하는 경우 하나의 레이어에서만 의존

---

## 이제 비싼 .NET이 아닙니다.

- C#으로 코드를 컴파일 → cli라는 가상 머신에서 실행
- 닷넷 프레임워크
- 닷넷 프레임워크로는 윈도우 어플리케이션, 웹서버 어플리케이션 등을 만들 수 있음
    - SSR에서도 똑같이 사용할 수 있음
- 닷넷과 자바를 비교
    - 닷넷은 윈도우에서만 개발 가능
    - visual studio를 사야만 개발 가능
    - 자바는 이클립스 무료, os도 다양한 운영체제에서 개발 가능하기 때문에 인기
- 닷넷 코어, 닷넷 프레임워크 비교
    - 닷넷 코어는 다양한 운영체제에서 개발 가능
- maui, unity…
    - 모노 프레임워크를 따로 쓰는 unity
- 닷넷7까지 현재 나와잇음
- entityFramework Core
    - .NET에서 쓰는 ORM
- 닷넷에서도 스웨거를 사용한다………
- `app.MapGet(”/url”, () ⇒ { });`
- C# 풀스택?………….
- JSP, .NET과 같은 SSR 방식
    - 브라우저 안에 모두 클라이언트 코드임
