**Clean architecture**

가장 중요한 것은 데이터베이스나 웹이 아닌 것 같다.

캐시, 비동기 등 어떤것도 담겨져있지만, 핵심 비즈니스로직과 유즈케이스가 가장 중요하다

핵심 비즈니스 데이터 + 핵심 비즈니스 로직 = 도메인 엔티티

유즈 케이스 : 시스템이 있어야 유효한 비즈니스 로직 = 입출력 + 비즈니스 로직

웹, 디비, 프레임워크는 필요없다.

도메인은 세부사항에 의존해서는 안된다.

바꾸고 싶은건 DB 접근기술인데 비즈니스 로직을 바꿀 수밖에 있다.

계층형 아키텍처는 우리에게 가장 익수갛고 잘 알려져있지만 문제점이 있다! (구현 방식에 따른 문제)

1. 디비 중심의 설계와 개발
    1. 현실세계에서 가장 중요한 것은 DB가 아니라 비즈니스 로직!
    2. 계층형에서 비즈니스 로직은 하나의 서비스에 구현된다
2. 멤버 관련 비즈니스 로직
3. 업무는 주로 유즈케이스 단위로 들어옴, 하나의 서비스에 유즈 케이스가 다 들어가있으면 생산성이 떨어진다.
    1. 테스트 관리가 어려워진다

빈약한 엔티티 모델 : 객체에 정보만 있고 아무런 기능도 갖고 있지 않는 모델

빈약 모델 쓰는 경우 비즈니스 로직은 서비스계층 -> 응집도가 떨어지고 테스트 번거로워진다., 서비스에 대한 의존관계 주입

풍부한 엔티티 모델 사용하기 -> 테스트 쉽고 객체지향적 코드

SRP = 하나의 일만 해야한다? X 변경의 이유가 하나여야한다! 하나의 액터만 책임져야한다.

일반적인 계층형은 SRP를 위반하기 쉽다!

서로다른 속도로 변경되는 코드들이 결합되기 쉽다.

고수준 : 입출력과 거리가 먼것

고수준, 저수준 영역은 서로 다른 속도로 변경된다.

일반적 계층형은 DIP를 위반하기 쉽다! -> 의존성을 역전시켜야한다.

레포지토리를 서비스에 위치시킨다 -> 똑같은 계층에 의존하기 때문에 세부 기능이 바뀌어도 비즈니스 로직을 보호할 수 있다.

1. 테스트 하기 쉽다. -> 스프링 없이도 테스트를 작성할 수 있어야한다!
2. 소리치는 아키텍처 : 어떤 프레임워크나 디비를 사용하는 지 등은 드러나지 않아도 되는 세부 사항이다.
    1. 새로 합류하느프로그래머는 어떤 시스템인지, 어떤 유즈케이스를 손쉽게 파악할 수 있어야하낟.
3. 플러그인 아키텍처
    1. 기술 교체를 수월하게 한다.
4. 도메인 중심 아키텍처 (DIP)
    1. 컴파일 소스코드 의존성과 런타임 실제 의존성은 다르다!
    2. DIP을 통해 영속성 의존성을 제거해야한다.
    3. Member 영속성 엔티티는 의존성 역전이 불가능하다.

엔티티를 서비스 계층으로 끌어올 수 있다. -> 순환의존성

인터페이스를 서비스 계층으로 두고, 구현을 레포지토리 계층에 둔다! -> 패키지간 의존성 X

영속성 컨텍스트때문에 보이지 않는 결함이 존재하게 된다 -> 엔티티를 분리한다!

(도메인 엔티티 / 영속성 엔티티 분리)

우리는 도메인 엔티티와 영속성 엔티티를 같이 쓰고 있음을 알고있어야한다.

1. 서비스계층(프레젠테이션 계층)을 유즈케이스 단위로 분리하라
    1. 테스트도 분리된다!
2. 추상화(PSA)되지 않은 세부사항에 의존한다면 DIP 사용
3. 객체의 데이터만 필요로하는 로직들은 객체의 내부로 이동시켜라
4. Package-private 가시성을 적극 활용하라

세부 결정 사항들은 최대한 미루자…. (늦장부리기)

나중에 구현 기술이 바뀔 수 있게 나중일은 최대한 늦게 결정하기

테이블 설계는 가장 나중으로 미룬다! (테이블에 확신이 들때까지 미룬다)

추상화를 미뤄라 -> 비용이 더 저렴해지는 시점까지 미룬다.

서비스 분리 -> 생존을 위해 분리하지 않으면 안되는 시점까지 미룬다.

캐시 적용 -> slow 요청들에 의해 필요해지는 시점까지 미룬다. (필요한 순간에만 써라)

좋은 아키텍처는 결정되지 않은 사항의 수를 최대화한다!

계층형아키텍처, 헥사고날 아키텍처, 유즈케이스 단위로 클래스 분리

도메인부터 많이 개발, 인테그레이션 테스트는 생략하는 경우도 있음

코드 리팩토링 수시로 해야하는데, 단위 테스트로 커버 안되는 부분은 통합테스트

통합테스트는 반드시 작성하지 않아도 되긴 한다.
